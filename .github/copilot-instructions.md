General Coding Standards
Our code should be clean, consistent, and easy to understand. Follow standard .NET coding conventions for naming, layout, and comments, as summarized here:
Naming Conventions
- PascalCase for types and members: Use PascalCase (capitalize each word) for all class names, structs, public methods, properties, and constants. For example, PlayerCharacter, UpdateScore(), and MaxHealth are correctly PascalCased. Interfaces should also use PascalCase, and be prefixed with an I (e.g. IInputManager). Do not prefix class, enum, or delegate names with any letter (no Hungarian notation). This follows .NET guidelines and makes names self-explanatory.
- camelCase for locals and fields: Use camelCase (first letter lowercase) for local variables, method parameters, and private fields. Private fields should additionally start with an underscore (_) as a prefix. For example, _currentLevel or _isGameOver for private fields, and elapsedTime or playerName for local variables. Avoid using Hungarian notation or type prefixes in names – let the type system and IDE convey the type instead.
- Descriptive and meaningful: Choose clear, meaningful names that reveal intent. For instance, use CalculatePlayerScore() instead of CalcPS(). This makes code more readable and often eliminates the need for additional comments. Abbreviations should be avoided (use InitializeGraphics() not InitGfx()) unless they are well-known acronyms. Consistent naming helps others (and Copilot) understand purpose without ambiguity.
Formatting and Layout
- Indentation and braces: Use 4 spaces per indentation level (no tab characters). Format braces in the Allman style – i.e., put the opening brace { on a new line after the declaration or statement. Each block's contents should be indented by 4 spaces. For example:
if (condition)
{
    // ...code...
}
else
{
    // ...code...
}
- One-line if/else statements can omit braces only if kept on a single line and the team is consistent about it, but generally we prefer always including braces for clarity and future maintainability.
- Spacing: Follow standard C# spacing conventions for readability. For example, put a space after commas in argument lists and between binary operators (x + y not x+y). Do not put unnecessary spaces inside parentheses or brackets (myArray[i] not myArray[ i ]). Also, do not add space between a method name and the following parenthesis (DoSomething() not DoSomething ()). Consistently use a single space before flow control keywords and after keywords like if, for, while (e.g. if (x > 0) not if(x>0)). These conventions improve code readability by keeping the style uniform.
- File and type organization: Stick to one public class per file, and name the file to match the class name. For example, Player.cs should contain the Player class. If additional internal classes are present, they should be closely related to the main class. Organize files into folders/namespaces that mirror the project structure (e.g., a Graphics folder and namespace for rendering-related classes). Within a class, group members logically (fields, properties, constructors, methods, etc.). You can use #region directives to collapse groups of related members (such as all fields under a "Fields" region) for easier navigation in large classes. Place using directives at the top of files, outside the namespace, and avoid unused usings.
- Line length and wrapping: Try to keep lines reasonably short (around 100-120 characters maximum) to avoid horizontal scrolling. Break up long parameter lists or expressions onto multiple lines as needed, indenting continuation lines. Each statement should typically be on its own line for clarity.
Comments and Documentation- Comment meaningfully: Use comments to explain the intent, rationale, or high-level overview of code – not to restate what the code is doing. For example, a good comment might explain why a certain workaround is in place, or what a block of code is accomplishing in game terms, rather than // increment x by 1. Avoid trivial comments; prefer self-explanatory code where possible. When using TODO or FIX comments, tag them clearly (e.g., // TODO: handle multiplayer case) so they can be found easily.
- XML documentation: For all public classes, methods, and properties, include XML documentation comments (/// <summary>...</summary>) describing their purpose and usage. Document parameters (<param name="...">) and return values (<returns>) where applicable. This helps generate intellisense tooltips and formal documentation. Internal/private members can have regular comments if needed for clarity, but key parts of the public API should be documented in XML. Example:
/// <summary>
/// Updates the player status based on elapsed time and input.
/// </summary>
/// <param name="gameTime">Time passed since last update frame.</param>
public void Update(GameTime gameTime)
{
    // ... update logic ...
}
- Ensure the summaries are clear and concise. This practice is aligned with producing maintainable, self-documenting code.
- Comment style: Use // for single-line comments. For any multi-line explanations or license headers, you can use /* ... */ block comments, but avoid nesting block comments. In general, place comments on their own line above the code they describe, not at the end of a line, to improve readability.
Architecture and Design GuidelinesWe aim for clean software architecture, following SOLID principles and proven design patterns where appropriate. Copilot should favor patterns that keep code modular, extensible, and easy to test:- Single Responsibility Principle: Each class or method should have a clear purpose or responsibility. Avoid God-classes that do too many unrelated things. For example, a Player class should probably handle player-specific logic, but the game physics or rendering might be handled by other classes. Similarly, keep methods focused; if a method is doing multiple distinct tasks, consider refactoring into separate methods. This makes code easier to understand, maintain, and unit test.
- Favor composition over inheritance: Limit class inheritance depth to only what is necessary (ideally no more than 2-3 levels deep). Deep inheritance hierarchies in games can become complicated and fragile. Instead, use composition and modular components to add behavior. For instance, rather than subclassing a base game object many times for different features, consider a component system (where a game entity has a list of components like “PhysicsComponent”, “RenderComponent”, etc.). MonoGame is flexible – you can use an entity-component system or event/delegate-based design to compose behaviors instead of relying solely on inheritance for code reuse. Keeping inheritance shallow (or using interfaces) will make suggestions more flexible and reduce tightly coupled code.
- Loose coupling and interfaces: Design classes to depend on abstractions (interfaces) rather than concrete implementations. Define interfaces for key systems (e.g., an ILogger for logging, an IInputService for input handling) and have concrete classes implement them. This allows swapping implementations (for example, a ConsoleLogger versus a FileLogger) without changing the classes that use them. Copilot should prefer to inject or retrieve an interface rather than instantiate a concrete class inside another class. This loose coupling makes our code more testable and flexible.
- Dependency injection: When a class needs to use another class, prefer passing it in (via constructor or setter) rather than instantiating inside the class. For example, if a GameScene class needs an IEnemySpawner, have it passed in through the GameScene constructor. This practice (manual dependency injection) decouples setup from usage. In a larger project, an IoC container or the built-in service provider could be used, but in MonoGame, a simpler pattern is to use the Game.Services container or to manually wire dependencies in the Game1 class. The key is that Copilot should avoid globally instantiating or using singletons unless necessary; instead, pass around references (or use the service locator) to keep code modular.
- Service locator (Game.Services): MonoGame’s Game.Services provides a way to register and retrieve services in a global context while still using interfaces. We use it to store instances that many parts of the game need (like an input manager, audio manager, etc.). When writing code, prefer obtaining shared services from this container instead of creating new instances. For example, we might register an IInputManager service in Game1.Initialize via Services.AddService(typeof(IInputManager), inputManagerInstance). Then anywhere in the game (with access to the Game), we can retrieve it: var input = Services.GetService<IInputManager>(); and use it. This avoids tight coupling to a specific input implementation and makes it easy for Copilot to suggest using the existing service. Ensure Copilot knows to use our service singletons rather than making new ones.
- Encapsulation: Keep fields private and expose them via properties or methods as needed (e.g., use public int Health { get; private set; } instead of a public field). This allows us to enforce invariants and add logic on access if needed (and it fits with the naming conventions above). Also use readonly for fields that should not change after construction (e.g., a reference to the game or a configuration object). Immutable design helps avoid bugs from unintended changes. Copilot should default to using properties to get or set values rather than directly accessing fields (except inside the class itself).
- Game state management: Organize the game into logical states or screens (for example, Main Menu, Gameplay, Pause, GameOver screens). Each state could be a class or a set of classes. This separation helps Copilot generate code in the right context. For instance, menu navigation code should be kept separate from gameplay logic. We might have a simple state machine or stack to switch between screens. Ensure that any code Copilot suggests for one state doesn’t inadvertently run in another. Using clear state checks or separate classes will help (e.g., a GameState enum or a base GameScreen class that Update/Draw only if active). This isn't a strict rule from a source, but a project-specific guideline to keep code organized.
- DRY principle: Avoid duplicating code. If Copilot suggests a chunk of logic that's very similar to existing code, consider refactoring into a common method or utility. Encourage Copilot to call existing methods rather than duplicate them if a function exists (for example, reuse a DamagePlayer(int amount) method instead of writing the damage logic again).
By following these design guidelines, the codebase remains modular and maintainable, and Copilot can assist by generating code that fits into this structure (e.g., using our interfaces, following our patterns of composition, etc.).Performance and Memory ConsiderationsGame performance is critical. We need to ensure that Copilot-generated code is efficient and avoids common performance pitfalls, especially in the game loop (the Update and Draw calls that run every frame). Keep the following best practices in mind:- Minimize garbage collection churn: Avoid allocating new objects within the per-frame Update or Draw methods whenever possible. Frequent allocations (e.g., creating new lists, strings, or class instances every frame) will trigger the garbage collector often, causing frame rate stutters. Instead, reuse objects or use object pools for recurring elements. For example, if spawning bullets frequently, consider an object pool of bullet objects to recycle rather than constantly newing them. Many game developers work to "allocate zero bytes during gameplay" as a goal. Copilot should favor patterns that reuse lists, pre-allocate buffers, and so on. If a method tends to allocate (like LINQ queries or string concatenations in a loop), be cautious – use simpler constructs to avoid garbage if in a hot path. By reducing allocations, we reduce GC pauses, resulting in smoother gameplay.
- Object pooling and caching: For objects that must be created, consider using caching or pooling techniques. For example, if we destroy and create a lot of enemy objects, we can keep a pool of inactive enemies to reactivate, instead of constantly allocating new ones. This reduces memory fragmentation and garbage collection overhead. Copilot can suggest retrieving an object from a pool (if we have one implemented) rather than constructing a new object, when applicable. Also, prefer StringBuilder for building long strings in loops (to avoid multiple string allocations), and use Array.Clear or reuse arrays where possible for large data sets.
- Manual GC timing: Do not manually call GC.Collect() during gameplay unless absolutely necessary. In general, rely on the .NET garbage collector to run on its own. If you must force a collection, do it at a safe moment (for instance, after a level ends or on a loading screen) when a pause will not disrupt gameplay. For example, it might be acceptable to call GC.Collect() during a screen transition when the player is not in control, but never call it each frame. Copilot should avoid suggesting manual garbage collection or finalizer suppression calls unless in engine shutdown or similar edge cases.
- Efficient Update loops: Keep the code in the Update() method optimized, as it runs every frame (typically 60 times per second). Use appropriate algorithms – for example, if checking collisions among many objects, Copilot might suggest a naive double loop; consider using spatial partitioning (quad-trees, grids) if the number of objects is large, to reduce checks. Avoid heavy operations in Update like extensive file I/O, reflection, or complex regex processing. If something is computationally expensive, see if it can be done once upfront (caching results) or spread out over multiple frames. Also, prefer using struct types (like Vector2, Rectangle) over creating new heap objects for simple data containers, since structs in .NET (especially immutable ones) can reduce garbage.
- Time-based movement: Use the gameTime delta for movement and animations to keep them frame-rate independent. MonoGame provides a GameTime object each frame with ElapsedGameTime. Always multiply movement or changes by gameTime.ElapsedGameTime.TotalSeconds (or milliseconds) so that if the frame rate drops or the game runs on a faster monitor, movement stays consistent. For example, if a character moves at 100 pixels/second, in Update do position += 100 * (float)gameTime.ElapsedGameTime.TotalSeconds. Copilot should incorporate this pattern rather than using fixed values per frame, ensuring consistency across different performance scenarios. (Note: In fixed-step mode MonoGame calls Update at a steady rate, but it’s still good practice to use the delta for correctness.)
- Fixed vs variable timestep: The project likely uses the default fixed timestep (60 FPS). If we ever switch to variable time step (IsFixedTimeStep = false), it's even more crucial to use ElapsedGameTime for physics and movement. Copilot should be aware of this – any physics or movement code should already be scaling by time. Also, if using fixed-step and IsRunningSlowly (when the game lags and MonoGame skips Draw calls), our logic still catches up correctly because it ran multiple Updates. So overall: always code assuming variable timing, which covers both modes.
- Multi-threading considerations: By default, MonoGame runs the Update and Draw on a single thread (the main thread). We can use background threads for loading assets or heavy computations, but we must be very careful with thread safety. Copilot should ensure that any suggestion to update game state from multiple threads is properly synchronized. Use locks or other synchronization primitives when accessing shared data from worker threads. For example, if a background thread is loading a level's data, protect any flags or lists it shares with the main thread (e.g., use lock on a common object or use thread-safe collections). Never call MonoGame graphics or audio API from a background thread – things like Texture2D creation or SpriteBatch.Draw must happen on the main thread because the graphics device context is single-threaded. If Copilot suggests using tasks/threads for performance, ensure it does not violate these rules (e.g., loading content on a background thread actually queues the load to main thread in MonoGame). It's okay to load file data or perform calculations off-thread, but then push the final texture creation or game object updates back to the main thread.
- Data structures: Use efficient data structures for the task. For example, use an array or List<T> for a collection you iterate every frame, rather than a LinkedList (array iteration is cache-friendly). Use dictionaries or sets for fast lookups. Copilot should lean towards the common structures (List, Dictionary, etc.) unless there's a known need for something else. Also, avoid repeatedly searching for objects in a list by attribute each frame; maintain dictionaries or maps if needed for quick access. In tight loops, avoid LINQ if it causes allocations or complexity; a simple for loop can be faster and clearer in those cases. Measure if in doubt – but as a rule, keep per-frame operations as straightforward as possible.
- Profile and optimize where needed: We will use profiling tools to find actual bottlenecks. Copilot should not prematurely micro-optimize at the cost of code clarity (for instance, unrolling loops or obscure tricks) unless a genuine hot-spot is identified. Write clear code first; optimize later if performance data shows an issue. For example, using LINQ for a simple iteration might be fine, but in a very hot inner loop it might be worth replacing with explicit code – we'll decide based on profiling. The key is: ensure suggestions are efficient in broad terms (no obviously slow operations in core loops), but maintain readability.
By following these performance guidelines, the game should run smoothly. Copilot should balance efficiency with clarity, leaning on these principles to avoid common slowdowns.MonoGame-Specific GuidelinesMonoGame has its own framework patterns and best practices inherited from XNA. The Copilot suggestions should align with how MonoGame expects you to structure your game. Below are guidelines specific to MonoGame development:- Use the Content Pipeline for assets: We manage game assets (textures, sounds, fonts, etc.) through the MonoGame Content Pipeline, not by loading files directly at runtime. Always use the Content.Load<T>(assetName) method to load assets that were added to the content pipeline, instead of methods like Texture2D.FromFile or raw file I/O. The content pipeline pre-processes content into an optimized .xnb format, yielding faster load times and automatic cross-platform compatibility (it handles platform-specific formats, compression, mipmaps, etc.). For example, to load a sprite texture named "Player.png" added to Content, use: playerTexture = Content.Load<Texture2D>("Player");. Copilot should avoid suggesting direct file paths or manual asset loading except for very dynamic cases (and even then, we prefer pipeline if possible). Rationale: Loading raw PNGs or MP3s at runtime is slower and uses more memory, whereas the pipeline can compress and optimize assets for us.
- Separate initialization, updating, and drawing: Adhere to the game loop structure provided by MonoGame. The Game class (usually Game1 in our project) has dedicated methods: Initialize(), LoadContent(), Update(GameTime), Draw(GameTime), etc. Copilot should place code in the appropriate override: use Initialize() for one-time setup of non-graphic resources or initializing game state, LoadContent() for loading all textures/sounds/effects via the Content pipeline, Update() for game logic and input processing, and Draw() for all rendering code. Do not perform rendering in Update and do not modify game state in Draw – keep them separated. For instance, if Copilot generates an example of moving a sprite, that logic should appear in Update(), whereas drawing that sprite belongs in Draw(). This separation is crucial for clarity and to avoid timing issues. Also, call base.Update(gameTime) and base.Draw(gameTime) in those overrides as needed so that MonoGame's base class can perform tasks like updating any registered GameComponents. If our game uses the Components system (where we add GameComponent or DrawableGameComponent objects to Game.Components), the base class will automatically call their Update and Draw if we include the base calls. Copilot should include base.Update()/base.Draw() at the end of our overrides unless there's a reason to override the behavior completely.
- Input handling: Use MonoGame’s input APIs (Keyboard.GetState(), GamePad.GetState(), Mouse.GetState()) inside the Update() method to handle user input. For example, to check if the Escape key is pressed: KeyboardState ks = Keyboard.GetState(); if (ks.IsKeyDown(Keys.Escape)) Exit();. Copilot should utilize these framework methods rather than attempting to read input via other means. Keep input polling in Update (not Draw), so it stays in sync with game state updates. Also, if the project uses an input wrapper service (like an IInputManager we wrote), Copilot should call that instead, as per our architecture.
- Use SpriteBatch for 2D rendering: To draw textures and text, always use a SpriteBatch. Typically, our Game1 has a SpriteBatch _spriteBatch created in LoadContent(). When drawing, do: spriteBatch.Begin(); ... spriteBatch.Draw(...); ... spriteBatch.End();. All sprite drawing calls must occur between a Begin() and End() call of a SpriteBatch. Copilot should never generate a spriteBatch.Draw outside of a Begin/End pair (except in special cases of immediate mode rendering which we are not using). Also ensure GraphicsDevice.Clear(...) is called at the start of each Draw() (the template usually does this) to clear the screen. Use the appropriate overloads of SpriteBatch.Draw – typically we provide the texture, position (as a Vector2 or Rectangle), optional source rectangle, tint color, rotation, origin, scale, effects, and layer depth as needed. For example: spriteBatch.Draw(playerTexture, playerPosition, Color.White); draws a texture at a given position fully opaque. For text, use a loaded SpriteFont and spriteBatch.DrawString. Copilot should favor these high-level drawing methods. We usually use one SpriteBatch for all 2D drawing per frame; there's rarely a need for multiple Begin() calls in our simple scenarios, unless we want different blend modes or sort modes.
- MonoGame types and utilities: Utilize MonoGame's provided types for game math and structures. For instance, use Vector2, Vector3 (from Microsoft.Xna.Framework) for positions and directions instead of creating your own 2D vector class. Use Rectangle for bounding boxes, Color for color values (MonoGame provides a Color struct with premade colors and RGBA). There's also Point for integer 2D positions and Matrix for transformations. Copilot should naturally use these types (as it likely will from context). For any math helpers, MonoGame has MathHelper (with useful constants and functions like MathHelper.Clamp, MathHelper.Lerp, etc.), and it’s better to use those or System.Math as needed rather than writing new math functions. Also prefer TimeSpan or the GameTime properties for timing rather than DIY timing logic with Environment.TickCount, etc.
- Resource management: MonoGame will automatically dispose content loaded through the ContentManager when the game exits or when Content.Unload() is called. If we manually create any IDisposable objects (e.g., RenderTarget2D, Texture2D from a stream, etc.), make sure to dispose them appropriately (e.g., in UnloadContent() or when switching game states) to avoid memory leaks. As a rule, do not manually dispose textures or sounds loaded via Content.Load during gameplay. If we need to free memory mid-game (say unloading a level), use a separate ContentManager for that level and call ContentManager.Unload() to free all its assets in one go. Copilot should understand that disposing a content-managed texture is not needed (and can cause errors if the ContentManager tries to use it later). Instead, let the content manager handle those, or unload the whole manager. For non-ContentManager assets, disposing when no longer needed is good (Copilot can suggest using using statements or try/finally to dispose if appropriate).
- Frame rate and VSync: The default template sets IsFixedTimeStep = true and a target of 60 FPS, and graphics.SynchronizeWithVerticalRetrace = true (VSync on). If we change these, it will be intentional. Generally, trust the framework to handle the timing. Copilot doesn't need to change these unless asked. Instead, focus on game code. If a suggestion involves timing (like a delay or cooldown mechanic), use GameTime or a timer mechanism in Update rather than Thread.Sleep, so we don’t block the main thread.
- Audio usage: Use MonoGame’s SoundEffect and Song classes for audio. E.g., load a SoundEffect via Content and call soundEffect.Play() to play it. For music, use MediaPlayer to play Song instances (remembering MonoGame’s limitation of one Song at a time). Ensure Copilot suggests using these rather than any System.Media or platform-specific audio APIs.
- Platform considerations: Our code should remain cross-platform. MonoGame abstracts most platform details, but be mindful not to use any Windows-only libraries (like System.Drawing or WPF/WinForms) for things like image loading or input – use MonoGame's framework classes instead. For file paths, use TitleContainer.OpenStream if reading content files that are not pipeline-managed (it works on all platforms). Copilot should avoid suggestions that involve file paths like "C:..." or P/Invoke calls, etc., which would break on other OSes.
File Size Limits:
No Code file should expand beyond 500 lines of code, methods and such should split across sub folders to maintain relationships and functionality.
By following these MonoGame-specific guidelines, the project will remain idiomatic to the framework. Copilot’s contributions should look like typical MonoGame code: using the provided Game structure, proper content loading, the Update/Draw pattern, and so on, ensuring any generated code fits seamlessly into our game.ExamplesBelow are a couple of examples illustrating these guidelines in practice. These are not exhaustive, but they show how we expect code to be structured and written.Example: Player Entity ClassIn this example, we create a Player class that represents a player in the game. It demonstrates proper naming, use of MonoGame types, separation of concerns for update and draw, and time-based movement./// <summary>
/// Represents a player-controlled character in the game.
/// </summary>
public class Player
{
    // Private fields (underscore + camelCase)
    private Texture2D _texture;
    private Vector2 _position;
    private float _speed;

    // Public property example
    public Vector2 Position 
    { 
        get => _position; 
        set => _position = value; 
    }

    // Constructor to initialize the player with a texture
    public Player(Texture2D texture)
    {
        _texture = texture;
        _position = Vector2.Zero;
        _speed = 100f; // speed in pixels per second
    }

    // Update method: handles player movement logic (Single Responsibility)
    public void Update(GameTime gameTime)
    {
        // Calculate time delta in seconds
        float delta = (float)gameTime.ElapsedGameTime.TotalSeconds;

        // Simple example movement: move to the right constantly at _speed
        _position.X += _speed * delta;

        // In a real game, you'd handle input here to change velocity or position
    }

    // Draw method: uses SpriteBatch to render the player
    public void Draw(SpriteBatch spriteBatch)
    {
        spriteBatch.Draw(_texture, _position, Color.White);
    }
}
Explanation: In this Player class, the naming follows our conventions (private fields like _texture, public property Position with PascalCase). The Update method uses the gameTime to move the player at a rate of _speed units per second, illustrating frame-independent movement. The Draw method takes a SpriteBatch (assumed to be provided by the caller, e.g., our main Game class) and draws the player's texture at the current position. Note that drawing is separated from updating: Update only changes state, while Draw only renders. This class is focused (it doesn't, for example, handle input directly or loading its own content – those would be handled elsewhere, keeping responsibilities separated). Comments and the XML doc comment show how we document the class and its methods.Example: Draw Method with SpriteBatchThe following snippet shows a typical override of the Draw method in our Game1 class (which inherits Microsoft.Xna.Framework.Game). It clears the screen and draws a couple of sprites. This demonstrates proper use of SpriteBatch.Begin()/End() and calling the base class draw at the end.protected override void Draw(GameTime gameTime)
{
    // Clear the screen to a solid color each frame
    GraphicsDevice.Clear(Color.CornflowerBlue);

    // Begin the sprite batch for 2D drawing
    _spriteBatch.Begin();

    // Draw a player texture and an enemy texture at specified positions
    _spriteBatch.Draw(playerTexture, new Vector2(100, 150), Color.White);
    _spriteBatch.Draw(enemyTexture, new Vector2(300, 150), Color.White);

    // End the sprite batch submission
    _spriteBatch.End();

    // Draw any UI or debug text (if needed)
    _spriteBatch.Begin();
    _spriteBatch.DrawString(uiFont, $"Score: {playerScore}", new Vector2(10, 10), Color.Yellow);
    _spriteBatch.End();

    // Call base.Draw so any registered DrawableGameComponents can draw
    base.Draw(gameTime);
}
Explanation: We first clear the screen to a background color (CornflowerBlue is the default in templates). Then we call _spriteBatch.Begin() to start drawing sprites. We draw two textures (player and enemy) at given positions with white tint (full opacity). All sprite drawing occurs between Begin() and End() calls. We ended the first batch, then started a new one to draw UI text (alternatively, we could have done all in one batch; here it's shown separately for clarity). After drawing everything, we call base.Draw(gameTime) which will allow any DrawableGameComponent added to the game to also draw themselves. This example follows the framework's pattern and our guidelines: using the SpriteBatch properly, clearing the screen, and organizing draw calls logically. Copilot should emulate this structure for any rendering code it suggests.